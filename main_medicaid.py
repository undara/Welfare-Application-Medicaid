# -*- coding: utf-8 -*-
"""main_medicaid.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jxCSEUk2mIFUkaY-uM1uLAUhP-PSZXqN
"""

# This code replicates the Empirical Application in
# Identification and Inference for Welfare Gains without Unconfoundedness
# Undral Byambadalai, Boston University
import pandas as pd 
import numpy as np
from sklearn.linear_model import LinearRegression
from sklearn.linear_model import LogisticRegression
from statsmodels.discrete.discrete_model import Probit
import matplotlib.pyplot as plt
import seaborn as sns

# Load data
path = '/content/ohie.csv'
ohie = pd.read_csv(path)

# Alternatively, use data URL from GitHub repository
# url = 'https://github.com/undara/Welfare-Application-Medicaid/blob/17eb70fbebea78cfc3ad2336cd48f78231cb1228/ohie.csv'
# ohie = pd.read_csv(url)

# Pick relevant variables
ohie = ohie[['person_id', 'treatment', 'ohp_all_ever_admin', 'returned_0m','hhinc_pctfpl_0m','health_gen_bin_0m']]

# Function to redefine health outcome variable (switch (0,1, NaN) to (1,0, NaN))
def recode_health(x):
  if x==1:
    return 0
  elif x==0:
    return 1  
  else:
    return x

# Apply the function to 0m survey data
ohie.health_gen_bin_0m = ohie.health_gen_bin_0m.apply(recode_health)

# Obtain subsample: those who responded to initial survey (26,423 individuals)
ohie_0m = ohie[ohie.returned_0m==1]
# Get summary statistics
print(ohie_0m.describe())
# Joint distribution of random offer and program enrollment
joint_dist_D_and_Z = ohie_0m[['treatment', 'ohp_all_ever_admin']].value_counts(normalize=True)
print(joint_dist_D_and_Z)
# Remove rows with missing values
ohie_0m = ohie_0m.dropna()

# Setup
y_under = 0
y_bar = 1
reg_choice = 'linear'

# Split data to treated and non treated
ohie_0m_d1 = ohie_0m[ohie_0m.ohp_all_ever_admin==1]
ohie_0m_d0 = ohie_0m[ohie_0m.ohp_all_ever_admin==0]

# Function to calculate eta1
def eta1(x_new, reg=reg_choice):
  y = ohie_0m_d1.health_gen_bin_0m
  x = ohie_0m_d1.hhinc_pctfpl_0m.values.reshape((-1, 1))
  if reg == 'linear':
    model = LinearRegression().fit(x,y)
    return model.predict(x_new)
  elif reg == 'probit':
    probit_model = Probit(y,x).fit()
    return probit_model.predict(x_new)

# Function to calculate eta0
def eta0(x_new, reg=reg_choice):
  y = ohie_0m_d0.health_gen_bin_0m
  x = ohie_0m_d0.hhinc_pctfpl_0m.values.reshape((-1, 1))
  if reg == 'linear':
    model = LinearRegression().fit(x,y)
    return model.predict(x_new)
  elif reg == 'probit':
    probit_model = Probit(y,x).fit()
    return probit_model.predict(x_new)

# Function to calculate p
def p(x_new, reg=reg_choice):
  y = ohie_0m.ohp_all_ever_admin
  x = ohie_0m.hhinc_pctfpl_0m.values.reshape((-1, 1))
  if reg == 'linear':
    model = LinearRegression().fit(x,y)
    return model.predict(x_new)
  elif reg == 'probit':
    probit_model = Probit(y,x).fit()
    return probit_model.predict(x_new)

# Function to calculate the worst-case lower bound
def beta_wc_l(x_new):
  n = x_new.shape[0]
  beta = 1/n*sum((eta1(x_new)-y_bar)*p(x_new)+(y_under-eta0(x_new))*(1-p(x_new)))
  return beta

# Function to calculate the worst-case upper bound
def beta_wc_u(x_new):
  n = x_new.shape[0]
  beta = 1/n*sum((eta1(x_new)-y_under)*p(x_new)+(y_bar-eta0(x_new))*(1-p(x_new)))
  return beta

# Relevant sample when policy1:treat<=100 and policy2: treat<=138
relevant_sample = ohie_0m[(ohie_0m.hhinc_pctfpl_0m >= 100)*(ohie_0m.hhinc_pctfpl_0m <= 138)] #1993 individuals
x_relevant = relevant_sample.hhinc_pctfpl_0m.values.reshape((-1,1))

# Calculate lower and upper bounds
beta_l = beta_wc_l(x_relevant)
beta_u = beta_wc_u(x_relevant)
print((beta_l,beta_u))

# Plot eta0
x0 = ohie_0m_d0.hhinc_pctfpl_0m.values.reshape((-1, 1))
y0 = ohie_0m_d0.health_gen_bin_0m
plt.scatter(x0, y0)
plt.plot(x0, eta0(x0))
plt.show()

# Plot eta1
y1 = ohie_0m_d1.health_gen_bin_0m
x1 = ohie_0m_d1.hhinc_pctfpl_0m.values.reshape((-1, 1))
plt.scatter(x1, y1)
plt.plot(x1, eta1(x1))
plt.show()

# Plot p
y = ohie_0m.ohp_all_ever_admin
x = ohie_0m.hhinc_pctfpl_0m.values.reshape((-1, 1))
plt.scatter(x, y)
plt.plot(x,p(x))
plt.show()

# Plot income
income = ohie_0m.hhinc_pctfpl_0m
sns.set_style('darkgrid')
sns.distplot(income)